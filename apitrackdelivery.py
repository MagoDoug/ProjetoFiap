# -*- coding: utf-8 -*-
"""APITrackDelivery.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xZk26yBpo5vbId_dDsfekWmDgT5Fpvxf
"""

from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from flasgger import Swagger

import sqlite3
import requests

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*")
Swagger(app) # Adiciona Swagger na API



OSM_BASE_URL = "https://nominatim.openstreetmap.org/reverse"
HEADERS = {"User-Agent": "MyTrackingApp/1.0 (magodoug@hotmail.com)"}  # Substitua pelo seu email

def init_db():
    conn = sqlite3.connect('database.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS entregadores (
                 id TEXT PRIMARY KEY,
                 latitude REAL,
                 longitude REAL)''')
    conn.commit()
    conn.close()


@app.route('/update_location', methods=['POST'])
def update_location():
    """
    Atualiza a localização do entregador
    ---
    tags:
      - Entregadores
    parameters:
      - in: body
        name: body
        required: true
        schema:
          type: object
          properties:
            id:
              type: string
              example: "123"
            latitude:
              type: number
              example: -23.55252
            longitude:
              type: number
              example: -46.634308
    responses:
      200:
        description: Localização atualizada com sucesso
    """
    data = request.get_json()
    entregador_id = data.get('id')
    latitude = data.get('latitude')
    longitude = data.get('longitude')

    if not entregador_id or latitude is None or longitude is None:
        return jsonify({'error': 'Dados inválidos'}), 400

    conn = sqlite3.connect('database.db')
    c = conn.cursor()
    c.execute("REPLACE INTO entregadores (id, latitude, longitude) VALUES (?, ?, ?)", (entregador_id, latitude, longitude))
    conn.commit()
    conn.close()

    # Enviar atualização para clientes conectados via WebSocket
    socketio.emit('location_update', {'id': entregador_id, 'latitude': latitude, 'longitude': longitude})

    return jsonify({'message': 'Localização atualizada com sucesso'})


@app.route('/get_location/<entregador_id>', methods=['GET'])
def get_location(entregador_id):
    """
    Obtém a localização do entregador
    ---
    tags:
      - Entregadores
    parameters:
      - name: entregador_id
        in: path
        required: true
        schema:
          type: string
          example: "123"
    responses:
      200:
        description: Retorna a localização do entregador
    """
    conn = sqlite3.connect('database.db')
    c = conn.cursor()
    c.execute("SELECT latitude, longitude FROM entregadores WHERE id = ?", (entregador_id,))
    row = c.fetchone()
    conn.close()

    if row:
        latitude, longitude = row
        try:
            response = requests.get(OSM_BASE_URL, params={
                "lat": latitude,
                "lon": longitude,
                "format": "json"
            }, headers=HEADERS)

            if response.status_code == 200:
                response_json = response.json()
                address = response_json.get("display_name", "Endereço não encontrado")
            else:
                print(f"Erro ao obter endereço: Status {response.status_code}, Resposta: {response.text}")
                address = "Erro ao obter endereço"
        except requests.exceptions.RequestException as e:
            print(f"Falha na comunicação com OpenStreetMap: {e}")
            address = "Falha na comunicação com OpenStreetMap"
        except ValueError:
            print(f"Resposta inválida do OpenStreetMap: {response.text}")
            address = "Resposta inválida do OpenStreetMap"

        #return jsonify({'id': entregador_id, 'latitude': latitude, 'longitude': longitude, 'address': address})
        return jsonify({'id': entregador_id, 'latitude': latitude, 'longitude': longitude})
    else:
        return jsonify({'error': 'Entregador não encontrado'}), 404

# Armazena o status do pedido
pedido_status = {}

@app.route('/update_status', methods=['POST'])
def update_status():
    """
    Atualiza o status de um pedido
    ---
    tags:
      - Pedidos
    parameters:
      - in: body
        name: body
        required: true
        schema:
          type: object
          properties:
            pedido_id:
              type: string
              example: "ABC123"
            status:
              type: string
              example: "Em Trânsito"
    responses:
      200:
        description: Status atualizado com sucesso
    """
    data = request.json
    pedido_id = data.get("pedido_id")
    status = data.get("status")

    if not pedido_id or not status:
        return jsonify({"error": "Pedido ID e status são obrigatórios"}), 400

    pedido_status[pedido_id] = status

    # Envia atualização para o WebSocket
    socketio.emit("status_update", {"pedido_id": pedido_id, "status": status})

    return jsonify({"message": "Status atualizado com sucesso!"})

@app.route('/get_status/<pedido_id>', methods=['GET'])
def get_status(pedido_id):
    """
    Obtém o status do pedido
    ---
    tags:
      - Pedidos
    parameters:
      - name: pedido_id
        in: path
        required: true
        schema:
          type: string
          example: "ABC123"
    responses:
      200:
        description: Retorna o status do pedido
    """
    status = pedido_status.get(pedido_id, "Desconhecido")
    return jsonify({"pedido_id": pedido_id, "status": status})

@socketio.on('connect')
def handle_connect():
    print('Cliente conectado')

@socketio.on('disconnect')
def handle_disconnect():
    print('Cliente desconectado')

if __name__ == '__main__':
    init_db()
    print("A API está rodando!")
    socketio.run(app, host='0.0.0.0', port=5000)